# Documentation du Code du Jeu *Sixteen-Soldiers*

Bienvenue dans la documentation compl√®te du code pour le projet *Sixteen-Soldiers*. Cette documentation vous guidera √† travers les √©tapes d'installation, de compr√©hension de l'architecture du projet, et de l'utilisation des classes et fonctions principales.  

## Table des mati√®res  
- [Installation et D√©bogage du Code üöÄ](#installation-et-d%C3%A9bogage-du-code-)  
- [Architecture des Fichiers üóÇÔ∏è](#architecture-des-fichiers-)  
- [Classes Utiles üîß](#classes-utiles-)  

---

## Installation et D√©bogage du Code üöÄ  

### Pr√©requis  

1. **Disposer de Python 3.12 ou version sup√©rieure**  
   Si Python n'est pas install√© sur votre machine, vous pouvez le t√©l√©charger et l'installer depuis le site officiel :  
   üëâ [T√©l√©charger Python](https://www.python.org/downloads/).  

   #### ‚öôÔ∏è **Installation de Python sous diff√©rents syst√®mes d'exploitation**  

   - **Windows** :  
     - T√©l√©chargez l'installateur correspondant √† votre architecture (32 ou 64 bits).  
     - Cochez l'option `Add Python to PATH` avant d'installer.  
     - Suivez les √©tapes de l'installateur.  

   - **macOS** :  
     - T√©l√©chargez l'installateur `.pkg` et suivez les instructions.  
     - Alternativement, vous pouvez utiliser `Homebrew` :  
       ```bash
       brew install python
       ```  

   - **Linux** :  
     - Utilisez votre gestionnaire de paquets. Par exemple, pour Ubuntu/Debian :  
       ```bash
       sudo apt update
       sudo apt install python3.12
       ```  

2. **V√©rification de la version de Python install√©e**  
   Apr√®s installation, ouvrez un terminal ou une invite de commande, et ex√©cutez :  
   ```bash
   python --version
   ```
   ou  
   ```bash
   python3 --version
   ```
   Vous devriez obtenir une version √©gale ou sup√©rieure √† `3.12`.  

---

### Installation des D√©pendances üì¶  

Le projet utilise un fichier `requirements.txt` pour g√©rer ses d√©pendances.  

1. Assurez-vous d'avoir `pip`, le gestionnaire de paquets Python. Vous pouvez le v√©rifier en ex√©cutant :  
   ```bash
   pip --version
   ```
   Si `pip` n'est pas install√©, vous pouvez l'ajouter via :  
   ```bash
   python -m ensurepip
   python -m pip install --upgrade pip
   ```

2. Placez-vous dans le r√©pertoire du projet, puis installez les d√©pendances avec la commande suivante :  
   ```bash
   pip install -r requirements.txt
   ```

   ‚úÖ **Cette commande installe tous les packages n√©cessaires pour ex√©cuter le projet.**  

---

### Ex√©cution du Code üèÅ  

1. Assurez-vous que l'installation s'est d√©roul√©e correctement en lan√ßant le projet :  
   ```bash
   python main.py
   ```
   ou  
   ```bash
   python3 main.py
   ```

2. **D√©bogage** :  
   Si des erreurs surviennent, v√©rifiez :  
   - Que tous les packages sont install√©s correctement.  
   - Que la version de Python est compatible.  
   - Consultez les logs g√©n√©r√©s pour identifier les probl√®mes sp√©cifiques.  

üéâ Une fois le programme ex√©cut√© avec succ√®s, vous √™tes pr√™t √† d√©couvrir les fonctionnalit√©s du jeu !  

---  


## Architecture des Fichiers üóÇÔ∏è  

L'architecture du projet est organis√©e pour faciliter la compr√©hension, l'extension et la maintenance du code. Chaque dossier a une responsabilit√© sp√©cifique. Voici un aper√ßu d√©taill√© :  

### **Dossier `agents` ü§ñ**  
Ce dossier contient les agents d'intelligence artificielle capables de jouer au jeu :  
- **`base_agent.py`** : Fournit une structure de base pour tous les agents.  
- **`random_agent.py`** : Un agent simple qui joue de mani√®re al√©atoire.  
- **`main_ai.py`** : L'agent principal utilis√© pour les comp√©titions.  

üí° **Note Importante :**  
- Si vous d√©veloppez une IA, cr√©ez un nouveau fichier pour chaque agent. Chaque fichier doit impl√©menter une classe retournant une action valide √† chaque appel. 

- Lorsque votre IA atteint un bon niveau, sauvegardez-la dans **`main_ai.py`**. Ce fichier sera utilis√© comme r√©f√©rence pour les comp√©titions r√©elles.  

---

### **Dossier `models` üèóÔ∏è**  
Ce dossier contient les mod√®les de donn√©es utilis√©s dans l‚Äôapplication :  
- **`board.py`** : Impl√©mente le plateau de jeu.  
  üîë **Astuce** : Ce fichier est crucial pour l‚Äôimpl√©mentation de vos IA. Consultez la **[class Board](#class-board)** pour mieux comprendre ses fonctionnalit√©s.  
- **`move.py`** : Repr√©sente les coups jou√©s dans le jeu. 

---

### **Dossier `actions` üéØ**  
Ce dossier regroupe toutes les actions possibles dans le jeu :  
- **`board_actions.py`** : G√®re les d√©placements des pions.  
- **`time_actions.py`** : G√®re la gestion du temps.  
- **`history_actions.py`** : G√®re l'historique des actions r√©alis√©es.  

---

### **Dossier `reducers` üîÑ**  
Les reducers sont responsables de la mise √† jour de l‚Äô√©tat global du jeu en fonction des actions re√ßues :  
- **`game_reducer.py`** : G√®re l‚Äô√©tat g√©n√©ral du jeu.  
- **`board_reducer.py`** : Met √† jour l‚Äô√©tat du plateau.  
- **`time_reducer.py`** : Traite la gestion des joueurs et du temps.  
- **`history_reducer.py`** : Met √† jour l‚Äôhistorique des coups jou√©s.  

---

### **Dossier `store` üìä**  
Le store contient l‚Äô√©tat global de l‚Äôapplication et les outils n√©cessaires pour g√©rer cet √©tat :  
- **Fonctions incluses** :  
  - *Dispatch* : Envoie des actions au reducer.  
  - *Subscribe* : Permet de surveiller les changements d‚Äô√©tat.  

---

### **Dossier `views` üñºÔ∏è**  
Les vues sont responsables de l'affichage du jeu. Chaque sous-vue est d√©di√©e √† une partie sp√©cifique de l'application :  
- **`base_view.py`** : D√©finit une interface commune pour toutes les vues.  
  ```python
  class BaseView:
      def subscribe(self, store): ...
      def update(self, state): ...
  ```  
- **`main_view.py`** : Coordonne la fen√™tre principale et les sous-vues.  
- Sous-vues sp√©cialis√©es :  
  - **`game_board.py`** : G√®re l‚Äôaffichage et l‚Äôinteraction avec le plateau.  
  - **`player_view.py`** : Affiche les informations des joueurs.  
  - **`history_view.py`** : Affiche l‚Äôhistorique des coups jou√©s.  
 

---

### **Dossier `utils` üõ†Ô∏è**  
Ce dossier contient des fonctions auxiliaires pour le projet :  
- **`validator.py`** : Valide les actions effectu√©es par les joueurs ou les agents.  
- **`audio.py`** : G√®re la musique et les sons.  
- **`const.py`** : Regroupe les constantes globales utilis√©es dans le projet.  

---

### **Dossier `saved_game` üíæ**  
Ce dossier contient les fichiers de sauvegarde des parties jou√©es. Vous pouvez y retrouver toutes vos parties enregistr√©es pour les analyser ou les rejouer.  

---

üëâ **[Suivant : Classes Utiles üîß](#classes-utiles-)**  

### Points √† Retenir üéØ  
1. La pr√©sentation de l'architecture est purement √† but informatif ou pour une meilleure prise en main du code. 

2. Impl√©mentez votre IA dans le dossier **`agents`**.  

3. Ne modifiez en aucun cas les dossiers mentionn√©s sauf (**`agents`**) au risque de faire crasher l'interface et vos IA. Tout crash, est par ailleurs, disqualificatif. 

4. Le fichier **`main_ai.py`** doit toujours contenir votre meilleure IA.  


## Classes Utiles üîß

### Classe `Board`

La classe `Board` repr√©sente le plateau de jeu et g√®re les mouvements et les captures des soldats.

#### Attributs

- `battle_field` (Dict[str, Set[str]]): Un dictionnaire repr√©sentant les positions adjacentes pour chaque position sur le plateau.
- `soldiers` (Dict[str, Soldier]): Un dictionnaire repr√©sentant la valeur du soldat √† chaque position sur le plateau.
- `last_action` (Dict): Le dernier mouvement effectu√©.
- `is_multiple_capture` (bool): Indique si une capture multiple est possible.
- `logger` (logging.Logger): Un logger pour enregistrer les √©v√©nements du jeu.

#### M√©thodes

##### `__init__(self)`

Initialise le plateau de jeu avec les positions des soldats rouges et bleus.

##### `get_neighbors(self, position: str) -> Dict[str, List[str]]`

Retourne les positions voisines d'une position donn√©e, class√©es par valeur (RED, BLUE, EMPTY).

- **Param√®tres**:
  - `position` (str): La position pour laquelle obtenir les voisins.
- **Retourne**:
  - Un dictionnaire avec les cl√©s `RED`, `BLUE`, et `EMPTY`, chacune contenant une liste de positions voisines.
    
    Exemple : 
    ```python
        {
            "RED": ["a3", "b2"],
            "BLUE": [],
            "EMPTY": ["c3"]
        }
     ```

##### `get_empty_positions(self) -> List[str]`

Retourne une liste de toutes les positions vides sur le plateau.

- **Retourne**:
  - Une liste de positions vides.

##### `get_soldier_positions(self, soldier_value: Soldier) -> List[str]`

Retourne une liste de toutes les positions occup√©es par les soldats d'une certaine valeur (RED ou BLUE).

- **Param√®tres**:
  - `soldier_value` (Soldier): La valeur du soldat (RED ou BLUE).
- **Retourne**:
  - Une liste de positions occup√©es par les soldats de la valeur sp√©cifi√©e.

##### `get_soldier_value(self, position: str) -> Soldier`

Retourne la valeur du soldat √† une position donn√©e.

- **Param√®tres**:
  - `position` (str): La position pour laquelle obtenir la valeur du soldat.
- **Retourne**:
  - La valeur du soldat √† la position sp√©cifi√©e.

##### `count_soldiers(self, soldier_value: Soldier) -> int`

Compte le nombre de soldats d'une certaine valeur sur le plateau.

- **Param√®tres**:
  - `soldier_value` (Soldier): La valeur du soldat (RED ou BLUE).
- **Retourne**:
  - Le nombre de soldats de la valeur sp√©cifi√©e.

##### `move_soldier(self, action: Dict)`

D√©place un soldat en fonction du dictionnaire d'action.

- **Param√®tres**:
  - `action` (Dict): Un dictionnaire contenant les d√©tails du mouvement (`from_pos`, `to_pos`, `soldier_value`).

##### `capture_soldier(self, action: Dict)`

Capture un soldat en fonction du dictionnaire d'action.

- **Param√®tres**:
  - `action` (Dict): Un dictionnaire contenant les d√©tails de la capture (`from_pos`, `to_pos`, `captured_soldier`, `soldier_value`).

##### `get_last_action(self) -> Dict`

Retourne le dernier mouvement effectu√©.

- **Retourne**:
  - Le dernier mouvement effectu√©.

##### `check_multi_capture(self, soldier_value: Soldier, current_position: str) -> bool`

V√©rifie si une capture multiple est possible.

- **Param√®tres**:
  - `soldier_value` (Soldier): La valeur du soldat (RED ou BLUE).
  - `current_position` (str): La position actuelle du soldat.
- **Retourne**:
  - `True` si une capture multiple est possible, `False` sinon.

##### `get_valid_actions(self) -> List[Dict]`

Retourne une liste de toutes les actions valides pour le joueur actuel.

- **Retourne**:
  - Une liste de dictionnaires repr√©sentant les actions valides.
    
    Exemple : 

    ```python
    [
        {
        "from_pos": "a1",
        "to_pos": "a3",
        "type": "MOVE",
        "soldier_value": "RED"
        }, 

        {
            ...
        }
    ]
    ```

##### `get_valid_actions_for_position(self, position: str) -> List[Dict]`

Retourne une liste de toutes les actions valides pour une position sp√©cifique.

- **Param√®tres**:
  - `position` (str): La position pour laquelle obtenir les actions valides.
- **Retourne**:
  - Une liste de dictionnaires repr√©sentant les actions valides pour la position sp√©cifi√©e.

##### `is_valid_move(self, from_pos: str, to_pos: str, soldier_value: Soldier) -> bool`

V√©rifie si un mouvement de `from_pos` √† `to_pos` est valide pour un soldat donn√©.

- **Param√®tres**:
  - `from_pos` (str): La position de d√©part.
  - `to_pos` (str): La position d'arriv√©e.
  - `soldier_value` (Soldier): La valeur du soldat (RED ou BLUE).
- **Retourne**:
  - `True` si le mouvement est valide, `False` sinon.

##### `is_game_over(self) -> Soldier`

V√©rifie si le jeu est termin√© (un joueur n'a plus de soldats).

- **Retourne**:
  - La valeur du soldat gagnant (RED ou BLUE) si le jeu est termin√©, `None` sinon.


<!-- ## Exemples d'Utilisation

### Initialisation
```python
board = Board()
```

### Affichage des Voisins
```python
neighbors = board.get_neighbors("c3")
print(neighbors)
# {"RED": ["b2", "b3"], "BLUE": [], "EMPTY": ["c2", "c4", "d4", "d3"]}
```

### Liste des Positions Vides
```python
empty_positions = board.get_empty_positions()
print(empty_positions)
# ["e3", "f2", "h4", ...]
```

### V√©rification d'un Mouvement
```python
is_valid = board.is_valid_move("a1", "a3", Soldier.RED)
print(is_valid)
# True ou False
```

### Effectuer un Mouvement
```python
action = {
    "from_pos": "a1",
    "to_pos": "a3",
    "soldier_value": Soldier.RED
}
board.move_soldier(action)
```

### V√©rification de Fin de Partie
```python
winner = board.is_game_over()
if winner:
    print(f"Le gagnant est : {winner.name}")
else:
    print("La partie continue.")
``` -->


<!-- ## Classe `BoardAction`

La classe `BoardAction` fournit des m√©thodes statiques pour cr√©er des actions de mouvement et de capture.

### M√©thodes

#### `move_soldier(from_pos: str, to_pos: str, soldier_value: Soldier) -> Dict`

Cr√©e une action de mouvement pour un soldat.

- **Param√®tres**:
  - `from_pos` (str): La position de d√©part.
  - `to_pos` (str): La position d'arriv√©e.
  - `soldier_value` (Soldier): La valeur du soldat (RED ou BLUE).
- **Retourne**:
  - Un dictionnaire repr√©sentant l'action de mouvement.

#### `capture_soldier(from_pos: str, to_pos: str, captured_soldier: str, soldier_value: Soldier) -> Dict`

Cr√©e une action de capture pour un soldat.

- **Param√®tres**:
  - `from_pos` (str): La position de d√©part.
  - `to_pos` (str): La position d'arriv√©e.
  - `captured_soldier` (str): La position du soldat captur√©.
  - `soldier_value` (Soldier): La valeur du soldat (RED ou BLUE).
- **Retourne**:
  - Un dictionnaire repr√©sentant l'action de capture. -->

<!-- 
### Classe `BoardUtils`

La classe `BoardUtils` fournit des utilitaires pour le plateau de jeu.

#### M√©thodes

##### `are_aligned(pos1: str, pos2: str, pos3: str) -> bool`

V√©rifie si trois positions sont align√©es.

- **Param√®tres**:
  - `pos1` (str): La premi√®re position.
  - `pos2` (str): La deuxi√®me position.
  - `pos3` (str): La troisi√®me position.
- **Retourne**:
  - `True` si les positions sont align√©es, `False` sinon.

##### `get_actions_soldier(battle_field: Dict[str, Set[str]], soldiers: Dict[str, Soldier], soldier_value: Soldier, last_position: str) -> List[Dict]`

Retourne une liste de toutes les actions valides pour un soldat donn√©.

- **Param√®tres**:
  - `battle_field` (Dict[str, Set[str]]): Le plateau de jeu.
  - `soldiers` (Dict[str, Soldier]): Les soldats sur le plateau.
  - `soldier_value` (Soldier): La valeur du soldat (RED ou BLUE).
  - `last_position` (str): La derni√®re position du soldat.
- **Retourne**:
  - Une liste de dictionnaires repr√©sentant les actions valides.

##### `find_continued_captures(battle_field: Dict[str, Set[str]], soldiers: Dict[str, Soldier], soldier_value: Soldier, last_position: str) -> List[Dict]`

Retourne une liste de toutes les captures continues possibles pour un soldat donn√©.

- **Param√®tres**:
  - `battle_field` (Dict[str, Set[str]]): Le plateau de jeu.
  - `soldiers` (Dict[str, Soldier]): Les soldats sur le plateau.
  - `soldier_value` (Soldier): La valeur du soldat (RED ou BLUE).
  - `last_position` (str): La derni√®re position du soldat.
- **Retourne**:
  - Une liste de dictionnaires repr√©sentant les captures continues possibles. -->

#### Utilisation

Pour utiliser ces attributs et m√©thodes, vous pouvez cr√©er une instance de la classe `Board` et appeler les m√©thodes appropri√©es pour g√©rer le jeu. Par exemple :

```python
board = Board()
print(board.get_neighbors('a1'))
print(board.get_soldier_positions(Soldier.RED))
print(board.get_valid_actions())
```





### Classe `Agent`

La classe `Agent` est une impl√©mentation d'un agent IA qui joue des mouvements valides dans le jeu Sixteen-Soldiers. Cette classe h√©rite de `BaseAgent` et peut √™tre utilis√©e comme point de d√©part pour cr√©er des agents IA plus sophistiqu√©s.

Dans le fichier `random_agent.py`, elle est impl√©ment√©e pour choisir une action al√©atoire parmi les actions valides. Ce fichier impl√©mente une classe Agent qui est donc principalement utilis√©e comme un point de d√©part ou pour des tests rapides. Elle n'est pas optimis√©e pour jouer strat√©giquement, mais elle offre une base fonctionnelle pour tester les interactions entre les composants du jeu.

#### Attributs

#### **Attributs de l'Agent**  
- **`soldier_value`** *(Soldier)* : La valeur du soldat que l'agent contr√¥le (RED ou BLUE).

- **`data`** *(Dict, optionnel)* : Permet de passer des donn√©es suppl√©mentaires √† l'agent (par exemple, des param√®tres ou des √©tats persistants).  
- **`name`** *(str)* : Nom de l'agent (d√©fini comme `"Random Team"` dans le cas du RandomPlayer).  


#### **M√©thodes Principales**  

##### **`__init__(self, soldier_value: Soldier, data: Dict = None)`**  
Le constructeur initialise l'agent avec une valeur de soldat et des donn√©es optionnelles.  
- **Param√®tres :**  
  - `soldier_value` : Identifie le type de soldat que cet agent contr√¥le (par exemple, un pion blanc ou noir).  
  - `data` : Dictionnaire facultatif pour passer des informations suppl√©mentaires.  

- **Exemple d'usage :**  
  ```python
  from src.utils.const import Soldier
  
  agent = Agent(soldier_value=Soldier.RED)
  print(agent.name)  # "Random Team"
  ```

---

#### **`choose_action(self, board: Board) -> Dict`**  
Cette m√©thode s√©lectionne une action valide au hasard parmi toutes les actions possibles pour cet agent.  

- **Param√®tres :**  
  - `board` : Instance de la classe **`Board`** repr√©sentant l'√©tat actuel du jeu.  

- **Retourne :**  
  - Un dictionnaire repr√©sentant l'action choisie. Chaque action est une structure pr√©d√©finie (voir la documentation de la m√©thode **`get_valid_actions()`** de la classe **`Board`** pour le format exact).  

- **Exemple de fonctionnement :**  
  Supposons que l'√©tat du plateau permette trois actions valides :  
  ```python
  [
      {"from_pos": 'd1', "to_pos": 'e1'},
      {"from_pos": 'd4', "to_pos": 'e5'},
      {"from_pos": 'a1', "to_pos": 'a3'},
  ]
  ```  
  La m√©thode choisira al√©atoirement une des trois actions disponibles.  

- **Code Simplifi√© :**  
  ```python
  valid_actions = board.get_valid_actions()
  return random.choice(valid_actions)
  ```  

---

#### Impl√©mentation de Nouveaux Agents

Pour impl√©menter un nouvel agent, vous pouvez h√©riter de la classe `BaseAgent` et red√©finir la m√©thode `choose_action` pour inclure votre logique personnalis√©e. Voici un exemple de comment cr√©er un nouvel agent :

Exemple Pratique : 

```python
from src.agents.base_agent import BaseAgent
from src.models.board import Board
from src.utils.const import Soldier

class CustomAgent(BaseAgent):
    """AI agent with custom logic"""

    def __init__(self, soldier_value: Soldier, data: Dict = None):
        super().__init__(soldier_value, data)
        self.name = "Custom Team"

    def choose_action(self, board: Board) -> Dict:
        """
        Choose an action based on custom logic.
        Args:
            board: Current game board state
        Returns:
            Custom chosen valid action for the soldier_value
        """
        valid_actions = board.get_valid_actions()

        # Impl√©mentez votre logique personnalis√©e ici
        best_action = self.custom_logic(valid_actions)

        return best_action

    def custom_logic(self, valid_actions: List[Dict]) -> Dict:
        """
        Custom logic to choose the best action.
        Args:
            valid_actions: List of valid actions
        Returns:
            Best action based on custom logic
        """
        # Impl√©mentez votre logique personnalis√©e ici

        return action

```


üí° **Attention :**

Ceci n'est qu'un exemple d'architecture de code pour l'impl√©mentation de la classe `Agent`. Vous n'avez pas √† impl√©menter une fonction `custom_logic` comme indiqu√© ici. Cependant, il est crucial de maintenir la fonction `choose_action`, qui sera appel√©e √† votre tour de jeu pour retourner l'action que vous souhaitez ex√©cuter. Vous pouvez personnaliser cette fonction en y int√©grant votre propre logique de d√©cision.




*Si vous avez des questions ou des difficult√©s, contactez-nous d√®s que possible.*

üìß Email : kyfaxgroup@gmail.com

üìû WhatsApp : https://chat.whatsapp.com/Lu4oj0uzr5g6lpG0HI54Xr


**Bon codage et amusez-vous bien !** üéâ 


                                      KYFAX ‚ú®
